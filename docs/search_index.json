[["index.html", "autovalid package guide Chapter 1 Package &amp; Guide Overview", " autovalid package guide MaryClare Roche 2023-09-26 Chapter 1 Package &amp; Guide Overview The autovalid package was developed by Gordon Arsenoff and MaryClare Roche to aid Arab Barometer in assessing survey data quality. This guide should serve as a reference for how to use the autovalid package and how to understand the results. "],["basic-use.html", "Chapter 2 Basic Use", " Chapter 2 Basic Use This chapter sheds light on how to use the autovalid package at the most basic level. There are four steps to run all the validation tests in autovalid. Load the necessary libraries. These libraries are readxl and autovalid. Load the raw data and save the path to the zip files. The zip files are NOT loaded. Only save the path. Use the prep_data() function from autovalid to create the object that will be used for validation. Run the autovalid() function on the output of prep_data(). Make sure to save the output to an object. The output of the function autovalid() contains the results of all the validation tests. Ultimately, if you follow the four steps, your code should follow the example of the following code block: #.........................Load Libraries......................... library(readxl) library(autovalid) #......................Load data and paths....................... raw_country_data &lt;- read_xls(&quot;path/to/raw/data.xlsx&quot;) audit_files &lt;- &quot;path/to/audits.zip&quot; #..........................Prep the data......................... prepped_data &lt;- prep_data(raw_country_data, audit_files) #..........................Run autovalid......................... validation_output &lt;- autovalid(prepped_data) Now that we have the results, we need to know how to understand them. A majority of the rest of the guide is dedicated to explaining the output of the autovalid() function. "],["output-overview.html", "Chapter 3 Output Overview 3.1 validation 3.2 raw_input 3.3 composite", " Chapter 3 Output Overview This chapter describes the output of the autovalid() function. The output of autovalid() is a slightly complex structure; it is a nested list. That is, the output is a list that contains a list. To help understand the output, all the elements are labeled. The overall output of autovalid() is a list of three objects called validation, raw_input, and composite. The latter two objects, raw_input and composite, are data frames. The object validation is a list of three more objects called responses, interviewers, and supervisors. Each of the objects in the validation list are data frames. The output looks like this list: validation (list) responses (data frame) interviewers (data frame) supervisors (data frame) raw_input (data frame) composite (data frame) The next sections look at each of the objects autovalid() returns. 3.1 validation As previously mentioned, validation is a list of three data frames. Each of the data frames is a set of validation test results. 3.1.1 responses The responses data frame contains all the interview-level checks run by autovalid(), as well as the _UUID, enumerator ID, supervisor ID, and group split the interview belonged to. 3.1.2 interviewers The interviewers data frame contains all the enumerator-level checks run by autovalid(), as well as enumerator ID, supervisor ID, and group split the interview belonged to. Most of these checks are the mean of the interview-level checks aggregated by enumerator. 3.1.3 supervisors The supervisors data frame contains all the supervisor-level checks run by autovalid(), as well as supervisor ID, and group split the interview belonged to. Most of these checks are the mean of the interview-level checks aggregated by supervisor. 3.2 raw_input The raw_input data frame is the condensed version of the raw data downloaded from KoboToolbox with non-valid interviews filtered out. The raw data downloaded from KoboToolbox has several “extra” columns from our efforts at randomization. The raw_input data frame collapses all these columns into one variable as appropriate. The raw_input only contains unique interviews the enumerator marks as “complete”. 3.3 composite The composite data frame is a data frame that contains all the interview responses from raw_input and all the interview-level tests from validation$responses. It is a result of joining the two data frame by _UUID. "],["output-name-conventions.html", "Chapter 4 Output Name Conventions 4.1 CHECK_ Variables 4.2 SCORE_ Variables", " Chapter 4 Output Name Conventions When exploring the output of autovalid(), you will see many variables that beging with CHECK_ or SCORE_. These prefixes tell you a bit about the variable. 4.1 CHECK_ Variables Variables that begin with the prefix CHECK_ are logicals, meaning the entire column is TRUE, FALSE, or occasionally NA. The question the variable is asking is “Is this check passed?” If the result is TRUE, the check is passed. If the result is FALSE, the check is failed. Interviews, enumerators, or supervisors flagged by autovalid() will have a lot of FALSE results. For example, the variable CHECK_TIMER1_ABOVE_MIN asks if Timer 1 is above the minimum time threshold. If CHECK_TIMER1_ABOVE_MIN is TRUE, the interview is over the minimum time threshold. If CHECK_TIMER1_ABOVE_MIN is FALSE, the interview is below the minimum time threshold. 4.2 SCORE_ Variables Variables that begin with the prefix SCORE_ are numeric and always fall between 0 and 1. This is because they are the mean of the all the CHECK_ variables in a category of validation tests. The category can be told by what follows SCORE_. For example, SCORE_LOGIC is the mean of all the logic validation tests that begin with CHECK_. Recall that the CHECK_ variables are all logicals. To computers, TRUE is 1 and FALSE is 0. The higher the SCORE_ variable, the more checks the interview, enumerator, or supervisor passed. "],["timer-checks.html", "Chapter 5 Timer Checks 5.1 Understanding the Four Timers 5.2 Time of Day 5.3 Min/Max Length 5.4 SCORE_TIMER 5.5 Changing Defaults 5.6 Result Columns", " Chapter 5 Timer Checks The autovalid() function performs ten checks related to time and gives an overall score. The results are in the columns: CHECK_TIMER1_AFTER_9AM CHECK_TIMER1_BEFORE_8PM CHECK_TIMER1_ABOVE_MIN CHECK_TIMER1_BELOW_MAX CHECK_TIMER2_ABOVE_MIN CHECK_TIMER2_BELOW_MAX CHECK_TIMER3_ABOVE_MIN CHECK_TIMER3_BELOW_MAX CHECK_TIMER4_ABOVE_MIN CHECK_TIMER4_BELOW_MAX SCORE_TIMER 5.1 Understanding the Four Timers autovalid() uses four different measures of time to calculate the length of a survey. These timers are called” TIMER1, TIMER2, TIMER3, and TIMER4. 5.1.1 TIMER1 TIMER1 is calculated from the start and end time recorded in the survey. These times are found in the raw data. The other three timers are all calculated from the audit files. 5.1.2 TIMER2 TIMER2 is calculated using the last recorded start and first recorded start in the associated interview’s audit file. All elements in an audit file have a start value, but not all have an end value, so that is why only values from the start column are used. 5.1.3 TIMER3 TIMER3 is calculated using the sum of the time spent on each page of the survey, according to the audit file. Once the survey and audit file timers start, they do not stop. If an interviewer leaves a survey and returns to it the duration of the survey may appear longer than it actually was. This timer does not include such pauses. 5.1.4 TIMER4 TIMER4 is calculated using the sum of the time spent on each page of the survey for questions that are between the first and last substantive question. By default, the first substantive question is set to \"Q2061A\" and the last substantive question is determined as the last question that begins with \"Q\". 5.2 Time of Day autovalid() uses the time recorded in the survey to determine whether the interview took place after 9am and before 8pm. 5.3 Min/Max Length The variables called CHECK_TIMERX_ABOVE_MIN and CHECK_TIMERX_BELOW_MAX, where X is 1 through 4, are all logicals telling the user whether the timer in question recorded a time above the minimum time and below the maximum time, respectively. By default, the minimum time is set to 30 minutes and the maximum time is set to 75 minutes. 5.4 SCORE_TIMER The SCORE_TIMER variable calculates the mean of all the check variables. 5.5 Changing Defaults There are four arguments in autovalid() that can be used to change the defaults for the timer checks. They are: thresh_opening: The earliest time of day an interview should begin. Use a 24 hour clock time. Default is 9. Associated with CHECK_TIMER1_AFTER_9AM. NOTE: Even if you change the default, the variable name will not change. It will still say CHECK_TIMER1_AFTER_9AM. thresh_closing: The latest time of day an interview should begin. Use a 24 hour clock time. Default is 20. Associated with CHECK_TIMER1_BEFORE_8PM. NOTE: Even if you change the default, the variable name will not change. It will still say CHECK_TIMER1_BEFORE_8PM. thresh_min_len: The minimum amount of time in minutes an interview should take. Use a positive integer. Default is 30. Associated with CHECK_TIMERX_ABOVE_MIN, where X is 1 through 4. thresh_max_len: The maximum amount of time in minutes an interview should take. Use a positive integer. Default is 75. Associated with CHECK_TIMERX_BELOW_MAX, where X is 1 through 4. The following is an example of changing the defaults in autovalid() for the timer checks. The object prepped_data is the output of the prep_data() function. See Chapter 2 for a refresher. autovalid(prepped_data, thresh_opening = 8, # Does the interview take place after 8am? thresh_closing = 16, # Does the interview take place before 4pm? thresh_min_len = 20, # Does the interview take longer than 20 minutes? thresh_max_len = 120 # Does the interview take less than 2 hours? ) 5.6 Result Columns There are an additional six column that are related to the timer checks that can be thought of as the “result columns”. They are TIMER1, TIMER2, TIMER3, TIMER4, COUNT_ABOVE_MIN and COUNT_BELOW_MAX. The first four simply record the time of the interview determined by each timer described in the sections above. The variables COUNT_ABOVE_MIN and COUNT_BELOW_MAX record the number of timers that pass the minimum and maximum length requirements, respectively. "],["varaince-checks.html", "Chapter 6 Variance Checks 6.1 SCORE_VARY 6.2 Result Columns", " Chapter 6 Variance Checks The tests are also known as “straightlining” checks. The autovalid() function checks whether the enumerator entered the same answer for all questions that appear on a page. This is particularly relevant to batteries, also known as grids. The resulting columns follow the naming pattern CHECK_QXX_VARIES where QXX is the root of the question battery/grid. For example, to see whether a interview contains the same answer for every question in the Q204 battery, look to the variable CHECK_Q204_VARIES. 6.1 SCORE_VARY The SCORE_VARY variable calculates the mean of all the CHECK_QXX_VARIES variables. The higher SCORE_VARY is, the fewer batteries are straightlined. The lower SOCRE_VARY, the more batteries contain all the same result (by individual battery). 6.2 Result Columns For each battery checked resulting in a CHECK_QXX_VARIES column, there is a QXX_RESPONSE column. If responses to the QXX battery vary, QXX_RESPONSE is NA. Otherwise, QXX_RESPONSE records the response used for every question in the battery. For example, if the same answer was recorded for every question in the Q204 battery, that answer would be recorded in Q204_RESPONSE. "],["missingness-checks.html", "Chapter 7 Missingness Checks 7.1 Changing Defualts 7.2 Result Columns", " Chapter 7 Missingness Checks The autovalid() function checks the level of missingness at both the interview- and enumerator-level. The result of the test is in: CHECK_MISS_IND A response is considered “missing” if it is coded as 98, 99, or 100. The missingness of an interview is calculated by the total number of missing responses divided by the total responses recorded. Only variables beginning with Q are counted. The variable CHECK_MIS_IND reports whether the percent of missing responses is below 15%. 7.1 Changing Defualts By default, autovalid() checks if the rate of missingness in an interview is below 15%. This can be changed with the argument thresh_mis_row using a numeric value between 0 and 1. The following is an example of changing the defaults in autovalid() for the missingness check. The object prepped_data is the output of the prep_data() function. See Chapter 2 for a refresher. autovalid(prepped_data, thresh_mis_row = .30 # Are more than 30% of answers 98/99/100? ) 7.2 Result Columns There is also a column that reports the percent missing for that interview. The column is called PCT_MISS. "],["percent-match.html", "Chapter 8 Percent Match Check 8.1 Changing Defaults 8.2 Result Columns", " Chapter 8 Percent Match Check The autovalid() function computes the percent match for each interview and checks whether it is below 85%. The result of the test is in: CHECK_PERCENT_MATCH. 8.1 Changing Defaults There are four arguments in autovalid() that can be used to change the default settings for the percent match check. thresh_max_pct : The highest percent one survey can match another. Use a number between 0 and 1. Defaults to 0.85. substantive_only : Whether to only include substantive questions. Must be TRUE or FALSE. Defaults to TRUE. first_sub_q : If only including substantive questions, where to start. Must be the name of a variable in the data. Defaults to \"Q2061A\". last_sub_q : If only including questions, where to end. Must be either the name of a variable in the data or \"auto\". Defaults to \"auto\". If argument is set to \"auto\", the autovalid() finds the last variable in the data beginning with \"Q\". The following is an example of changing the defaults in autovalid() for the percent match check. The object prepped_data is the output of the prep_data() function. See Chapter 2 for a refresher. autovalid(prepped_data, thresh_max_pct = 0.90, # Does the interview match below 90%? substantive_only = FALSE, # Include all questions in calculation first_sub_q = &quot;Q101&quot;, # Subset columns starting at Q101 (not relevant here) last_sub_q = &quot;Q700A_1&quot; # Subset columns ending at Q700A_1 (not relevant here) ) ## Note: The arguments `first_sub_q` and `last_sub_q` would be irrelevant in this case, ## since `substantive_only` is set to FALSE. 8.2 Result Columns The result of the percent match calculation can be found in PCT_MATCH. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
